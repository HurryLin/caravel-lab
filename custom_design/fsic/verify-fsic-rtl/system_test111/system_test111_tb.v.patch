// SPDX-FileCopyrightText: 2020 Efabless Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// SPDX-License-Identifier: Apache-2.0

`default_nettype none

`timescale 1 ns / 1 ps

/*
`define UNIT_DELAY         #1
`define USE_POWER_PINS
`define SIM_TIME           100_000

`include "libs.ref/sky130_fd_sc_hd/verilog/primitives.v"
`include "libs.ref/sky130_fd_sc_hd/verilog/sky130_fd_sc_hd.v"

`include "libs.ref/sky130_fd_sc_hvl/verilog/primitives.v"
`include "libs.ref/sky130_fd_sc_hvl/verilog/sky130_fd_sc_hvl.v"

`include "libs.ref/sky130_fd_sc_hd/verilog/primitives.v"
`include "libs.ref/sky130_fd_sc_hd/verilog/sky130_fd_sc_hd.v"

`include "libs.ref/sky130_fd_sc_hvl/verilog/primitives.v"
`include "libs.ref/sky130_fd_sc_hvl/verilog/sky130_fd_sc_hvl.v"

`include "libs.ref/sky130_fd_io/verilog/sky130_fd_io.v"
`include "libs.ref/sky130_fd_io/verilog/sky130_ef_io.v"
`include "libs.ref/sky130_fd_io/verilog/sky130_ef_io__gpiov2_pad_wrapped.v"

*/
// --------------------------------------------------------
// define only one of below items
// --------------------------------------------------------
`define SYSTEM_test111 1
//`define SYSTEM_test112 1
//`define SYSTEM_test103 1
//`define SYSTEM_test104 1
//`define SYSTEM_test113 1
//`define SYSTEM_test114 1


// `include "defines.v
// `include "__uprj_netlists.v"
// `include "caravel_netlists.v"
// `include "spiflash.v"

// ------------------------------------------------------------------------------

`include "project_define.svh"

module system_test111_tb #( parameter BITS=32,
        parameter pSERIALIO_WIDTH   = 12,
        parameter pADDR_WIDTH   = 15,
        parameter pDATA_WIDTH   = 32,
        parameter IOCLK_Period    = 10,
        // parameter DLYCLK_Period    = 1,
        parameter SHIFT_DEPTH = 5,
        parameter pRxFIFO_DEPTH = 5,
        parameter pCLK_RATIO = 4
    )
(
);
  `include "bench_ini.svh"
        localparam CoreClkPhaseLoop    = 1;
        localparam UP_BASE=32'h3000_0000;
        localparam AA_BASE=32'h3000_2000;
        localparam IS_BASE=32'h3000_3000;

        localparam SOC_to_FPGA_MailBox_Base=28'h000_2000;
        localparam FPGA_to_SOC_AA_BASE=28'h000_2000;
        localparam FPGA_to_SOC_IS_BASE=28'h000_3000;
        
        localparam AA_MailBox_Reg_Offset=12'h000;
        localparam AA_Internal_Reg_Offset=12'h100;
        
        localparam TUSER_AXIS = 2'b00;
        localparam TUSER_AXILITE_WRITE = 2'b01;
        localparam TUSER_AXILITE_READ_REQ = 2'b10;
        localparam TUSER_AXILITE_READ_CPL = 2'b11;

        localparam TID_DN_UP = 2'b00;
        localparam TID_DN_AA = 2'b01;
        localparam TID_UP_UP = 2'b00;
        localparam TID_UP_AA = 2'b01;
        localparam TID_UP_LA = 2'b10;

  wire        gpio;
  wire [37:0] mprj_io;
  wire        flash_csb;
  wire        flash_clk;
  wire        flash_io0;
  wire        flash_io1;
  wire        SDO;

    reg fpga_rst;
    //reg soc_resetb;        //POR reset
    reg fpga_resetb;    //POR reset    
    wire fpga_coreclk;

    //write addr channel
    reg fpga_axi_awvalid;
    reg [pADDR_WIDTH-1:0] fpga_axi_awaddr;
    wire fpga_axi_awready;
    
    //write data channel
    reg     fpga_axi_wvalid;
    reg     [pDATA_WIDTH-1:0] fpga_axi_wdata;
    reg     [3:0] fpga_axi_wstrb;
    wire    fpga_axi_wready;
    
    //read addr channel
    reg     fpga_axi_arvalid;
    reg     [pADDR_WIDTH-1:0] fpga_axi_araddr;
    wire     fpga_axi_arready;
    
    //read data channel
    wire     fpga_axi_rvalid;
    wire     [pDATA_WIDTH-1:0] fpga_axi_rdata;
    reg     fpga_axi_rready;
    
    reg     fpga_cc_is_enable;        //axi_lite enable

    wire [pSERIALIO_WIDTH-1:0] soc_serial_txd;
    wire soc_txclk;
    wire fpga_txclk;
    
    reg [pDATA_WIDTH-1:0] fpga_as_is_tdata;
    reg [3:0] fpga_as_is_tstrb;
    reg [3:0] fpga_as_is_tkeep;
    reg fpga_as_is_tlast;
    reg [1:0] fpga_as_is_tid;
    reg fpga_as_is_tvalid;
    reg [1:0] fpga_as_is_tuser;
    reg fpga_as_is_tready;        //when local side axis switch Rxfifo size <= threshold then as_is_tready=0; this flow control mechanism is for notify remote side do not provide data with is_as_tvalid=1

    wire [pSERIALIO_WIDTH-1:0] fpga_serial_txd;
//    wire [7:0] fpga_Serial_Data_Out_tdata;
//    wire fpga_Serial_Data_Out_tstrb;
//    wire fpga_Serial_Data_Out_tkeep;
//    wire fpga_Serial_Data_Out_tid_tuser;    // tid and tuser    
//    wire fpga_Serial_Data_Out_tlast_tvalid_tready;        //flowcontrol

    wire [pDATA_WIDTH-1:0] fpga_is_as_tdata;
    wire [3:0] fpga_is_as_tstrb;
    wire [3:0] fpga_is_as_tkeep;
    wire fpga_is_as_tlast;
    wire [1:0] fpga_is_as_tid;
    wire fpga_is_as_tvalid;
    wire [1:0] fpga_is_as_tuser;
    wire fpga_is_as_tready;        //when remote side axis switch Rxfifo size <= threshold then is_as_tready=0, this flow control mechanism is for notify local side do not provide data with as_is_tvalid=1

  reg [27:0] fpga_axilite_write_addr;

    reg[27:0] soc_to_fpga_mailbox_write_addr_expect_value;
    reg[3:0] soc_to_fpga_mailbox_write_addr_BE_expect_value;
    reg[31:0] soc_to_fpga_mailbox_write_data_expect_value;
    reg [31:0] soc_to_fpga_mailbox_write_addr_captured;
    reg [31:0] soc_to_fpga_mailbox_write_data_captured;
    event soc_to_fpga_mailbox_write_event;

    reg [31:0] soc_to_fpga_axilite_read_cpl_expect_value;
    reg [31:0] soc_to_fpga_axilite_read_cpl_captured;
    event soc_to_fpga_axilite_read_cpl_event;

    reg [31:0] error_cnt;
    reg [31:0] check_cnt;
  reg finish_flag;
  
  // wire [11:0] checkbits;
  // assign      checkbits = uut.mprj_io_out[32:21];

  //wire  [7:0] spivalue;
  //assign      spivalue  = mprj_io[15: 8];

  reg         power1;  // 3.3V
  reg         power2;  // 1.8V

  // External clock is used by default.  Make this artificially fast for the
  // simulation.  Normally this would be a slow clock and the digital PLL
  // would be the fast clock.
  //
  reg clock;
  reg io_clk;   // generated from FPGA in real system

  localparam pSOC_FREQ = 10.0;                 // 10 MHz
  localparam pIOS_FREQ = (pSOC_FREQ * 4.0);    // 40 MHz

  // Timing Order
  // POWER ==> CLOCK ==> RESET

  initial begin
    clock  = 0;
    wait(power2);
    #100;
    forever begin
      #(500.0 / pSOC_FREQ);
      clock = ~clock;
    end
  end

  initial begin
    io_clk  = 0;
    wait(power2);
    #100;
    forever begin
      #(500.0 / pIOS_FREQ);
      io_clk = ~io_clk;
    end
  end

  wire [11:0] rx_dat;
  wire        rx_clk;
  // TBD
  assign #1 rx_clk = io_clk;
  // TBD
  assign #2 rx_dat = 12'h000;


    assign mprj_io[37] = io_clk;
    assign mprj_io[20] = fpga_txclk;
    assign mprj_io[19:8] = fpga_serial_txd;

    assign soc_txclk = mprj_io[33];
    assign soc_serial_txd = mprj_io[32:21];


   initial begin
        $dumpfile("system_test111.vcd");
        $dumpvars(0, system_test111_tb);

    `ifdef SYSTEM_test111
    test111();
    `endif //SYSTEM_test111

    `ifdef SYSTEM_test112
    test112();
    `endif //SYSTEM_test112
    
    `ifdef SYSTEM_test103
    test103();
    `endif //SYSTEM_test103

    `ifdef SYSTEM_test104
    test104();
    `endif //SYSTEM_test104


    `ifdef SYSTEM_test113
    test113();
    `endif //SYSTEM_test113

    `ifdef SYSTEM_test114
    test114();
    `endif //SYSTEM_test114

    end

  wire ioclk;
  assign ioclk = io_clk;

  reg [31:0] repeat_cnt;
  
  initial begin
    $timeformat (-9, 3, " ns", 13);
  //$dumpfile("top_bench.vcd");
  //$dumpvars(0, top_bench);
    error_cnt = 0;
    check_cnt = 0;
    finish_flag = 0;
    repeat_cnt = 0;


    do begin
        repeat_cnt = repeat_cnt + 1;
        repeat (1000) @(posedge clock);
        $display("%t MSG %m, +1000 cycles, finish_flag=%b,  repeat_cnt=%04d", $time, finish_flag, repeat_cnt);
    end
    while(finish_flag == 0 && repeat_cnt <= 100 );


    $display("=============================================================================================");
    $display("=============================================================================================");
    $display("=============================================================================================");
    if (error_cnt != 0 ) begin
        $display("%c[1;31m",27);
        $display($time, "=> Final result [FAILED], check_cnt = %d, error_cnt = %d, please search [ERROR] in the log", check_cnt, error_cnt);
        $display("%c[0m",27);
    end
    else begin
        $display($time, "=> Final result [PASS], check_cnt = %d, error_cnt = %04d", check_cnt, error_cnt);
    end
    $display("=============================================================================================");
    $display("=============================================================================================");
    $display("=============================================================================================");

    //$display("%c[1;31m",27);
    //$display ("Monitor: Timeout, Test Failed");
    //$display("%c[0m",27);
    $finish;
  end

  reg RSTB;



  initial begin
    RSTB <= 1'b0;
    wait(power2);
    #400;
    $display("%t MSG %m, Chip Reset# is released ", $time);
    RSTB <= 1'b1;      // Release reset
    #2000;
  end

  initial begin
    power1 <= 1'b0;
    power2 <= 1'b0;
    #200;
    power1 <= 1'b1;
    #200;
    power2 <= 1'b1;
  end

/*
  always @(checkbits) begin
    //#1 $display("GPIO state = %b ", checkbits);
    #1 $display("%t IOCLK = %b, TX_CLK=%b, TXD=%b, RX_CLK=%b, RXD=%b,  ", $time, uut.mprj_io_in[37], uut.mprj_io_out[33], uut.mprj_io_out[32:21], uut.mprj_io_in[20], uut.mprj_io_in[19:8]);
  end
*/


    initial begin        //when soc cfg write to AA, then AA in soc generate soc_to_fpga_mailbox_write, 
        while (1) begin
            @(posedge fpga_coreclk);
            if (fpga_is_as_tvalid == 1 && fpga_is_as_tid == TID_UP_AA && fpga_is_as_tuser == TUSER_AXILITE_WRITE && fpga_is_as_tlast == 0) begin
                $display($time, "=> get soc_to_fpga_mailbox_write_addr_captured be : soc_to_fpga_mailbox_write_addr_captured =%x, fpga_is_as_tdata=%x", soc_to_fpga_mailbox_write_addr_captured, fpga_is_as_tdata);
                soc_to_fpga_mailbox_write_addr_captured = fpga_is_as_tdata ;        //use block assignment
                $display($time, "=> get soc_to_fpga_mailbox_write_addr_captured af : soc_to_fpga_mailbox_write_addr_captured =%x, fpga_is_as_tdata=%x", soc_to_fpga_mailbox_write_addr_captured, fpga_is_as_tdata);
                @(posedge fpga_coreclk);
                $display($time, "=> get soc_to_fpga_mailbox_write_data_captured be : soc_to_fpga_mailbox_write_data_captured =%x, fpga_is_as_tdata=%x", soc_to_fpga_mailbox_write_data_captured, fpga_is_as_tdata);
                soc_to_fpga_mailbox_write_data_captured = fpga_is_as_tdata ;        //use block assignment
                $display($time, "=> get soc_to_fpga_mailbox_write_data_captured af : soc_to_fpga_mailbox_write_data_captured =%x, fpga_is_as_tdata=%x", soc_to_fpga_mailbox_write_data_captured, fpga_is_as_tdata);
                #0 -> soc_to_fpga_mailbox_write_event;

                $display($time, "=> soc_to_fpga_mailbox_write_data_captured : send soc_to_fpga_mailbox_write_event");

            end    
        end
    end

  

  `ifdef SYSTEM_test111
  reg [31:0] idx5;
  initial begin        

    // test111 - for soc CFG write to mailbox 
    // 1. [FW] SOC CFG write to mailbox 
    // 1.A [testbech] check soc_to_fpga_mailbox_write 

    for (idx5 = 0 ; idx5 < 32'h10 ; idx5=idx5+4) begin
      soc_to_fpga_mailbox_write_addr_expect_value = 28'h000_2000 + idx5;
      soc_to_fpga_mailbox_write_addr_BE_expect_value = 4'b1111;
      soc_to_fpga_mailbox_write_data_expect_value = 32'h5a5a_5a5a; 
      
      wait_and_check_soc_to_fpga_mailbox_write_event();
      soc_to_fpga_mailbox_write_data_expect_value = 32'ha5a5_a5a5; 
      wait_and_check_soc_to_fpga_mailbox_write_event();
    end
    finish_flag = 1;

  end
  `endif //SYSTEM_test111
  
  `ifdef SYSTEM_test112
    // test112 - for soc CFG read and write to mailbox then send to fpga
    // 1. [FW] SOC CFG read and write to mailbox 
    // 1.A [testbech] check soc_to_fpga_mailbox_write 

    //for SOC internal register read/write test and update the result to mailbox, testbench check the data when received the mail box write.
    initial begin        //when soc cfg write to AA, then AA in soc generate soc_to_fpga_mailbox_write, 

    soc_to_fpga_mailbox_write_addr_expect_value = 28'h000_2000;
    soc_to_fpga_mailbox_write_addr_BE_expect_value = 4'b1111;
    soc_to_fpga_mailbox_write_data_expect_value = 32'h0; 
    wait_and_check_soc_to_fpga_mailbox_write_event();
    soc_to_fpga_mailbox_write_data_expect_value = 32'h1; 
    wait_and_check_soc_to_fpga_mailbox_write_event();
    soc_to_fpga_mailbox_write_data_expect_value = 32'h3; 
    wait_and_check_soc_to_fpga_mailbox_write_event();
    
    finish_flag = 1;
    end
  `endif //SYSTEM_test112


  wire VDD3V3;
  wire VDD1V8;
  wire VSS;
  
  assign VDD3V3 = power1;
  assign VDD1V8 = power2;
  assign VSS    = 1'b0;

  // These are the mappings of mprj_io GPIO pads that are set to
  // specific functions on startup:
  //
  // JTAG      = mgmt_gpio_io[0]              (inout)
  // SDO       = mgmt_gpio_io[1]              (output)
  // SDI       = mgmt_gpio_io[2]              (input)
  // CSB       = mgmt_gpio_io[3]              (input)
  // SCK       = mgmt_gpio_io[4]              (input)
  // ser_rx    = mgmt_gpio_io[5]              (input)
  // ser_tx    = mgmt_gpio_io[6]              (output)
  // irq       = mgmt_gpio_io[7]              (input)


  // move to bench_vec.svh
  // assign mprj_io[3] = 1'b1;  // Force CSB high.

  caravel uut (.vddio     (VDD3V3),
               .vddio_2   (VDD3V3),
               .vssio     (VSS),
               .vssio_2   (VSS),
               .vdda      (VDD3V3),
               .vssa      (VSS),
               .vccd      (VDD1V8),
               .vssd      (VSS),
               .vdda1     (VDD3V3),
               .vdda1_2   (VDD3V3),
               .vdda2     (VDD3V3),
               .vssa1     (VSS),
               .vssa1_2   (VSS),
               .vssa2     (VSS),
               .vccd1     (VDD1V8),
               .vccd2     (VDD1V8),
               .vssd1     (VSS),
               .vssd2     (VSS),
               .clock     (clock),
               .gpio      (gpio),
               .mprj_io   (mprj_io),
               .flash_csb (flash_csb),
               .flash_clk (flash_clk),
               .flash_io0 (flash_io0),
               .flash_io1 (flash_io1),
               .resetb    (RSTB) );


  spiflash #(.FILENAME("system_test111.hex")) spiflash ( .csb(flash_csb),
                                              .clk(flash_clk),
                                              .io0(flash_io0),
                                              .io1(flash_io1),
                                              .io2(),          // not used
                                              .io3() );        // not used
    fsic_clock_div fpga_clock_div (
    .resetb(fpga_resetb),
    .in(ioclk),
    .out(fpga_coreclk)
    );

    fpga  #(
        .pSERIALIO_WIDTH(pSERIALIO_WIDTH),
        .pADDR_WIDTH(pADDR_WIDTH),
        .pDATA_WIDTH(pDATA_WIDTH),
        .pRxFIFO_DEPTH(pRxFIFO_DEPTH),
        .pCLK_RATIO(pCLK_RATIO)
    )
    fpga_fsic(
        .axis_rst_n(~fpga_rst),
        .axi_reset_n(~fpga_rst),
        .serial_tclk(fpga_txclk),
        .serial_rclk(soc_txclk),
        .ioclk(ioclk),
        .axis_clk(fpga_coreclk),
        .axi_clk(fpga_coreclk),
        
        //write addr channel
        .axi_awvalid_s_awvalid(fpga_axi_awvalid),
        .axi_awaddr_s_awaddr(fpga_axi_awaddr),
        .axi_awready_axi_awready3(fpga_axi_awready),

        //write data channel
        .axi_wvalid_s_wvalid(fpga_axi_wvalid),
        .axi_wdata_s_wdata(fpga_axi_wdata),
        .axi_wstrb_s_wstrb(fpga_axi_wstrb),
        .axi_wready_axi_wready3(fpga_axi_wready),

        //read addr channel
        .axi_arvalid_s_arvalid(fpga_axi_arvalid),
        .axi_araddr_s_araddr(fpga_axi_araddr),
        .axi_arready_axi_arready3(fpga_axi_arready),
        
        //read data channel
        .axi_rvalid_axi_rvalid3(fpga_axi_rvalid),
        .axi_rdata_axi_rdata3(fpga_axi_rdata),
        .axi_rready_s_rready(fpga_axi_rready),
        
        .cc_is_enable(fpga_cc_is_enable),


        .as_is_tdata(fpga_as_is_tdata),
        .as_is_tstrb(fpga_as_is_tstrb),
        .as_is_tkeep(fpga_as_is_tkeep),
        .as_is_tlast(fpga_as_is_tlast),
        .as_is_tid(fpga_as_is_tid),
        .as_is_tvalid(fpga_as_is_tvalid),
        .as_is_tuser(fpga_as_is_tuser),
        .as_is_tready(fpga_as_is_tready),
        .serial_txd(fpga_serial_txd),
        .serial_rxd(soc_serial_txd),
        .is_as_tdata(fpga_is_as_tdata),
        .is_as_tstrb(fpga_is_as_tstrb),
        .is_as_tkeep(fpga_is_as_tkeep),
        .is_as_tlast(fpga_is_as_tlast),
        .is_as_tid(fpga_is_as_tid),
        .is_as_tvalid(fpga_is_as_tvalid),
        .is_as_tuser(fpga_is_as_tuser),
        .is_as_tready(fpga_is_as_tready)
    );

  reg [31:0] i;
  
    task fpga_apply_reset;
        input real delta1;        // for POR De-Assert
        input real delta2;        // for reset De-Assert
        begin
            #(40);
            $display($time, "=> fpga POR Assert"); 
            fpga_resetb = 0;
            $display($time, "=> fpga reset Assert"); 
            fpga_rst = 1;
            #(delta1);

            $display($time, "=> fpga POR De-Assert"); 
            fpga_resetb = 1;

            #(delta2);
            $display($time, "=> fpga reset De-Assert"); 
            fpga_rst = 0;
        end
    endtask

  task init_fpga_as;
    begin
                #40;

                fpga_as_to_is_init();
                
                //soc_cc_is_enable=1;
                fpga_cc_is_enable=1;

                #400;
                $display($time, "=> wait uut.mprj.u_fsic.U_IO_SERDES0.rxen");
//tony_debug        wait(uut.mprj.u_fsic.U_IO_SERDES0.rxen);
                $display($time, "=> detect uut.mprj.u_fsic.U_IO_SERDES0.rxen=1");

                fpga_cfg_write(0,1,1,0);
                $display($time, "=> fpga rxen_ctl=1");
        
                repeat(4) @(posedge fpga_coreclk);
                fork 
                    //soc_is_cfg_write(0, 4'b0001, 3);                //ioserdes txen
                    fpga_cfg_write(0,3,1,0);
                join
                //$display($time, "=> soc txen_ctl=1");
                $display($time, "=> fpga txen_ctl=1");

                #200;
                fpga_as_is_tdata = 32'h5a5a5a5a;
                #40;
                #200;
    end
    endtask
  
    task test111;        //test111_soc_to_fpga_mailbox_write
    // test111 - for soc CFG write to mailbox 
    // 1. [FW] SOC CFG write to mailbox 
    // 1.A [testbech] check soc_to_fpga_mailbox_write 

        begin
            for (i=0;i<CoreClkPhaseLoop;i=i+1) begin
                $display("test111: test111_soc_to_fpga_mailbox_write - loop %02d", i);
                fork 
                    //soc_apply_reset(40+i*10, 40);            //change coreclk phase in soc
                    fpga_apply_reset(40,40);        //fix coreclk phase in fpga
                join
        init_fpga_as();
            end
        end
    endtask

    task test112;        
    // test112 - for_soc_CFG_read_and_write_to_mailbox_then_send_to_fpga
    // 1. [FW] SOC CFG read and write to mailbox 
    // 1.A [testbech] check soc_to_fpga_mailbox_write 
    //SOC internal register read/write test and update the result to mailbox, testbench check the data when received the mail box write.

        begin
            for (i=0;i<CoreClkPhaseLoop;i=i+1) begin
                $display("test111: for_soc_CFG_read_and_write_to_mailbox_then_send_to_fpga - loop %02d", i);
                fork 
                    //soc_apply_reset(40+i*10, 40);            //change coreclk phase in soc
                    fpga_apply_reset(40,40);        //fix coreclk phase in fpga
                join
        init_fpga_as();
            end
        end
    endtask

    task test103;   //test103_fpga_to_soc_cfg_read
    // test103 - test103_fpga_to_soc_cfg_read
    // 1. [testbech] fpga to soc CFG read
    // 2. [HW] SOC return CFG read cpl to fpga, (FW code only need to init REG_IS_BASE)
    // 2.A [testbech] check CFG read cpl in fpga
        begin
            for (i=0;i<CoreClkPhaseLoop;i=i+1) begin
                $display("test103: fpga_cfg_read test - loop %02d", i);
                fork 
                    //soc_apply_reset(40+i*10, 40);            //change coreclk phase in soc
                    fpga_apply_reset(40,40);        //fix coreclk phase in fpga
                join
        init_fpga_as();
                test103_fpga_to_soc_cfg_read();
                #200;
            end
      finish_flag=1;
        end
    endtask

    task test104;   //test104_fpga_to_soc_mail_box_write
    // test104 - fpga to soc mailbox loopback test
    // 1. [testbech] fpga to soc mialbox write to offset 0
    // 2. [FW] soc read mailbox offset 0, if non zero then write the read_value to mailbox offset 4
    // 2.A [testbech] check soc to fpga mailbox write to offset 4 in fpga
        begin
            for (i=0;i<CoreClkPhaseLoop;i=i+1) begin
                $display("test104: TX/RX test - loop %02d", i);
                fork 
                    //soc_apply_reset(40+i*10, 40);            //change coreclk phase in soc
                    fpga_apply_reset(40,40);        //fix coreclk phase in fpga
                join
        init_fpga_as();
                test104_fpga_to_soc_mail_box_write();        //target to AA
                #200;
            end
      finish_flag=1;
        end

    endtask
  
    task test104_fpga_to_soc_mail_box_write;
        //input [7:0] compare_data;

        //FPGA to SOC Axilite test
        begin
            @ (posedge fpga_coreclk);
            fpga_as_is_tready <= 1;
            
            $display($time, "=> test104_fpga_to_soc_mail_box_write start");
      soc_to_fpga_mailbox_write_addr_expect_value = 28'h000_2000 + 4;
      soc_to_fpga_mailbox_write_addr_BE_expect_value = 4'b1111;
      soc_to_fpga_mailbox_write_data_expect_value = 32'h1111_1111; 

    // 1. [testbech] fpga to soc mialbox write to offset 0
    // 2.A [testbech] check soc to fpga mailbox write to offset 4 in fpga

            fpga_axilite_write(FPGA_to_SOC_AA_BASE + AA_MailBox_Reg_Offset + 0, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
            $display($time, "=> test104_fpga_to_soc_mail_box_write fpga_axilite_write addr = %x, be=%x, data = %x", FPGA_to_SOC_AA_BASE + AA_MailBox_Reg_Offset + 0, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
      wait_and_check_soc_to_fpga_mailbox_write_event();

            $display($time, "=> test104_fpga_to_soc_mail_box_write done");
        end
    endtask

    task test113;   //test113_fpga_to_soc_CFG_write
    // test113 - fpga to soc CFG write test
    // 1. [testbech] fpga to soc CFG write to AA_Internal_Reg_Offset + 0
    // 2. [FW] soc read AA_Internal_Reg_Offset + 0, if non zero then write the read_value to mailbox offset 4
    // 2.A [testbech] check soc to fpga mailbox write to offset 4 in fpga
        begin
            for (i=0;i<CoreClkPhaseLoop;i=i+1) begin
                $display("test113: TX/RX test - loop %02d", i);
                fork 
                    //soc_apply_reset(40+i*10, 40);            //change coreclk phase in soc
                    fpga_apply_reset(40,40);        //fix coreclk phase in fpga
                join
        init_fpga_as();
                test113_fpga_to_soc_CFG_write();        //target to AA_Internal_Reg_Offset
                #200;
            end
      finish_flag=1;
        end

    endtask

    task test113_fpga_to_soc_CFG_write;
        //FPGA to SOC Axilite test
        begin
            @ (posedge fpga_coreclk);
            fpga_as_is_tready <= 1;
            
            $display($time, "=> test113_fpga_to_soc_CFG_write start");
      fpga_axilite_write_addr = FPGA_to_SOC_AA_BASE + AA_Internal_Reg_Offset + 0;
      soc_to_fpga_mailbox_write_addr_expect_value = FPGA_to_SOC_AA_BASE + AA_MailBox_Reg_Offset + 4;
      soc_to_fpga_mailbox_write_addr_BE_expect_value = 4'b1111;
      soc_to_fpga_mailbox_write_data_expect_value = 32'h1; 

    // 1. [testbech] fpga to soc CFG write to AA_Internal_Reg_Offset + 0
    // 2.A [testbech] check soc to fpga mailbox write to offset 4 in fpga

            fpga_axilite_write(fpga_axilite_write_addr, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
            $display($time, "=> test113_fpga_to_soc_CFG_write fpga_axilite_write_addr = %x, be=%x, data = %x", fpga_axilite_write_addr, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
      wait_and_check_soc_to_fpga_mailbox_write_event();

            $display($time, "=> test113_fpga_to_soc_CFG_write done");
        end
    endtask

    task test114;   //fpga to soc mailbox write with interrupt test
    //test114 - fpga to soc mailbox write with interrupt test
    // 1. [FW] init interrupt handler
    // 1.A [FW] soc enable interrupt by set AA_Internal_Reg_Offset + 0 = 1
    // 2. [testbech] fpga to soc CFG write to AA_MailBox_Reg_Offset + 0 = value
    // 3. [FW] in isr read value from AA_MailBox_Reg_Offset + 0 and write to AA_MailBox_Reg_Offset + 4
    // 4. [testbech] fpga check AA_MailBox_Reg_Offset + 4 = value
        begin
        `ifdef USER_PROJ_IRQ0_EN
            $display("USER_PROJ_IRQ0 Test");
        `endif         
    
            for (i=0;i<CoreClkPhaseLoop;i=i+1) begin
                $display("test114: TX/RX test - loop %02d", i);
                fork 
                    //soc_apply_reset(40+i*10, 40);            //change coreclk phase in soc
                    fpga_apply_reset(40,40);        //fix coreclk phase in fpga
                join
        init_fpga_as();
                $display($time, "=> wait uut.mprj.u_fsic.U_AXIL_AXIS0.axi_ctrl_logic.aa_regs[0][0] (interrupt enable bit)");
//tony_debug        wait(uut.mprj.u_fsic.U_AXIL_AXIS0.axi_ctrl_logic.aa_regs[0][0]); //wait interrupt enable bit = 1
                $display($time, "=> detect uut.mprj.u_fsic.U_AXIL_AXIS0.axi_ctrl_logic.aa_regs[0][0]=1");
                test114_fpga_to_soc_CFG_write();        //target to AA_MailBox_Reg_Offset
                #200;
            end
      finish_flag=1;
        end

    endtask

    task test114_fpga_to_soc_CFG_write;
        //FPGA to SOC Axilite test
        begin
            @ (posedge fpga_coreclk);
            fpga_as_is_tready <= 1;
            
            $display($time, "=> test114_fpga_to_soc_CFG_write start");
      fpga_axilite_write_addr = FPGA_to_SOC_AA_BASE + AA_MailBox_Reg_Offset + 0;

      soc_to_fpga_mailbox_write_addr_expect_value = FPGA_to_SOC_AA_BASE + AA_MailBox_Reg_Offset + 4;
      soc_to_fpga_mailbox_write_addr_BE_expect_value = 4'b1111;
      soc_to_fpga_mailbox_write_data_expect_value = 32'h1; 

    // 1. [testbech] fpga to soc CFG write to AA_MailBox_Reg_Offset + 0
    // 2.A [testbech] check soc to fpga mailbox write to offset 4 in fpga

            fpga_axilite_write(fpga_axilite_write_addr, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
            $display($time, "=> test114_fpga_to_soc_CFG_write fpga_axilite_write_addr = %x, be=%x, data = %x", fpga_axilite_write_addr, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
      wait_and_check_soc_to_fpga_mailbox_write_event();
            $display($time, "=> test114_fpga_to_soc_CFG_write wait 320us");
                  repeat(8000) @(posedge fpga_coreclk); //wait 320us

      fpga_axilite_write_addr = FPGA_to_SOC_AA_BASE + AA_MailBox_Reg_Offset + 0;
      soc_to_fpga_mailbox_write_addr_expect_value = FPGA_to_SOC_AA_BASE + AA_MailBox_Reg_Offset + 4;
      soc_to_fpga_mailbox_write_addr_BE_expect_value = 4'b1111;
      soc_to_fpga_mailbox_write_data_expect_value = 32'h5a5a_5a5a; 

    // 1. [testbech] fpga to soc CFG write to AA_MailBox_Reg_Offset + 0
    // 2.A [testbech] check soc to fpga mailbox write to offset 4 in fpga

            fpga_axilite_write(fpga_axilite_write_addr, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
            $display($time, "=> test114_fpga_to_soc_CFG_write fpga_axilite_write_addr = %x, be=%x, data = %x", fpga_axilite_write_addr, soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_data_expect_value);
      wait_and_check_soc_to_fpga_mailbox_write_event();

            $display($time, "=> test114_fpga_to_soc_CFG_write done");
      
      
        end
    endtask

    task fpga_axilite_write;
        input [27:0] address;
        input [3:0] BE;
        input [31:0] data;
        begin
            fpga_as_is_tdata <= (BE<<28) + address;    //for axilite write address phase
            //$strobe($time, "=> fpga_as_is_tdata in address phase = %x", fpga_as_is_tdata);
            fpga_as_is_tstrb <=  4'b0000;
            fpga_as_is_tkeep <=  4'b0000;
            fpga_as_is_tid <=  TID_DN_AA ;        //target to Axis-Axilite
            fpga_as_is_tuser <=  TUSER_AXILITE_WRITE;        //for axilite write
            fpga_as_is_tlast <=  1'b0;
            fpga_as_is_tvalid <= 1;

            @ (posedge fpga_coreclk);
            while (fpga_is_as_tready == 0) begin        // wait util fpga_is_as_tready == 1 then change data
                    @ (posedge fpga_coreclk);
            end

            fpga_as_is_tdata <=  data;    //for axilite write data phase
            fpga_as_is_tstrb <=  4'b0000;
            fpga_as_is_tkeep <=  4'b0000;
            fpga_as_is_tid <=  TID_DN_AA;        //target to Axis-Axilite
            fpga_as_is_tuser <=  TUSER_AXILITE_WRITE;        //for axilite write
            fpga_as_is_tlast <=  1'b0;
            fpga_as_is_tvalid <= 1;

            @ (posedge fpga_coreclk);
            while (fpga_is_as_tready == 0) begin        // wait util fpga_is_as_tready == 1 then change data
                    @ (posedge fpga_coreclk);
            end
            fpga_as_is_tvalid <= 0;
        
        end
    endtask

    reg[31:0]idx2;

    task test103_fpga_to_soc_cfg_read;        //target to io serdes
        //input [7:0] compare_data;

        //FPGA to SOC Axilite test
        begin

            @ (posedge fpga_coreclk);
            fpga_as_is_tready <= 1;
            
            for(idx2=0; idx2<32/4; idx2=idx2+1)begin        //
                //step 1. fpga issue cfg read request to soc
        soc_to_fpga_axilite_read_cpl_expect_value = 32'h3;
                fpga_axilite_read_req(FPGA_to_SOC_IS_BASE + idx2*4);
                    //read address = h0000_3000 ~ h0000_301F for io serdes
                //step 2. fpga wait for read completion from soc
                $display($time, "=> test103_fpga_to_soc_cfg_read :wait for soc_to_fpga_axilite_read_cpl_event");
                //tony_debug wait(soc_to_fpga_axilite_read_cpl_event.triggered);        //wait for fpga get the read cpl.
                @(soc_to_fpga_axilite_read_cpl_event);        //wait for fpga get the read cpl.
                $display($time, "=> test103_fpga_to_soc_cfg_read : got soc_to_fpga_axilite_read_cpl_event");

                $display($time, "=> test103_fpga_to_soc_cfg_read : soc_to_fpga_axilite_read_cpl_captured=%x", soc_to_fpga_axilite_read_cpl_captured);
        
                //Data part
        check_cnt = check_cnt + 1;
                if ( soc_to_fpga_axilite_read_cpl_expect_value !== soc_to_fpga_axilite_read_cpl_captured) begin
                    $display($time, "=> test103_fpga_to_soc_cfg_read [ERROR] soc_to_fpga_axilite_read_cpl_expect_value=%x, soc_to_fpga_axilite_read_cpl_captured[27:0]=%x", soc_to_fpga_axilite_read_cpl_expect_value, soc_to_fpga_axilite_read_cpl_captured[27:0]);
                    error_cnt = error_cnt + 1;
                end    
                else
                    $display($time, "=> test103_fpga_to_soc_cfg_read [PASS] soc_to_fpga_axilite_read_cpl_expect_value=%x, soc_to_fpga_axilite_read_cpl_captured[27:0]=%x", soc_to_fpga_axilite_read_cpl_expect_value, soc_to_fpga_axilite_read_cpl_captured[27:0]);
            end
            $display($time, "=> test103_fpga_to_soc_cfg_read done");
        end
    endtask

    task fpga_axilite_read_req;
        input [31:0] address;
        begin
            fpga_as_is_tdata <= address;    //for axilite read address req phase
            $strobe($time, "=> fpga_axilite_read_req in address req phase = %x - tvalid", fpga_as_is_tdata);
            fpga_as_is_tstrb <=  4'b0000;
            fpga_as_is_tkeep <=  4'b0000;
            fpga_as_is_tid <=  TID_DN_AA;        //target to Axis-Axilite
            fpga_as_is_tuser <=  TUSER_AXILITE_READ_REQ;        //for axilite read req
            fpga_as_is_tlast <=  1'b0;
            fpga_as_is_tvalid <= 1;

            @ (posedge fpga_coreclk);
            while (fpga_is_as_tready == 0) begin        // wait util fpga_is_as_tready == 1 then change data
                    @ (posedge fpga_coreclk);
            end
            $display($time, "=> fpga_axilite_read_req in address req phase = %x - transfer", fpga_as_is_tdata);
            fpga_as_is_tvalid <= 0;
        
        end
    endtask


    reg[31:0]idx3;

    task test111_fpga_axis_req;
        //input [7:0] compare_data;

        //FPGA to SOC Axilite test
        begin
            //tony_Debug force uut.AXIS_SW0.up_as_tready = 1;

            @ (posedge fpga_coreclk);
            fpga_as_is_tready <= 1;
            
            for(idx3=0; idx3<32; idx3=idx3+1)begin        //
                fpga_axis_req(32'h11111111 * (idx3 & 32'h0000_000F), TID_DN_UP);        //target to User Project
                //if (idx3 > 12 )             force dut.AXIS_SW0.up_as_tready = 1;
            end
            //tony_Debug release dut.AXIS_SW0.up_as_tready;
            
            $display($time, "=> test111_fpga_axis_req done");
        end
    endtask

    task fpga_axis_req;
        input [31:0] data;
        input [1:0] tid;
        begin
            fpga_as_is_tdata <= data;    //for axis write data
            $strobe($time, "=> fpga_axis_req fpga_as_is_tdata = %x", fpga_as_is_tdata);
            fpga_as_is_tstrb <=  4'b0000;
            fpga_as_is_tkeep <=  4'b0000;
            fpga_as_is_tid <=  tid;        //set target
            fpga_as_is_tuser <=  TUSER_AXIS;        //for axis req
            fpga_as_is_tlast <=  1'b0;
            fpga_as_is_tvalid <= 1;

            @ (posedge fpga_coreclk);
            while (fpga_is_as_tready == 0) begin        // wait util fpga_is_as_tready == 1 then change data
                    @ (posedge fpga_coreclk);
            end
            fpga_as_is_tvalid <= 0;
        
        end
    endtask

    task fpga_as_to_is_init;
        //input [7:0] compare_data;

        begin
            //init fpga as to is signal, set fpga_as_is_tready = 1 for receives data from soc
            @ (posedge fpga_coreclk);
            fpga_as_is_tdata <=  32'h0;
            fpga_as_is_tstrb <=  4'b0000;
            fpga_as_is_tkeep <=  4'b0000;
            fpga_as_is_tid <=  TID_DN_UP;
            fpga_as_is_tuser <=  TUSER_AXIS;
            fpga_as_is_tlast <=  1'b0;
            fpga_as_is_tvalid <= 0;
            fpga_as_is_tready <= 1;
            $display($time, "=> fpga_as_to_is_init done");
        end
    endtask

    task fpga_cfg_write;        //input addr, data, strb and valid_delay 
        input [pADDR_WIDTH-1:0] axi_awaddr;
        input [pDATA_WIDTH-1:0] axi_wdata;
        input [3:0] axi_wstrb;
        input [7:0] valid_delay;
        
        begin
            fpga_axi_awaddr <= axi_awaddr;
            fpga_axi_awvalid <= 0;
            fpga_axi_wdata <= axi_wdata;
            fpga_axi_wstrb <= axi_wstrb;
            fpga_axi_wvalid <= 0;
            //$display($time, "=> fpga_delay_valid before : valid_delay=%x", valid_delay); 
            repeat (valid_delay) @ (posedge fpga_coreclk);
            //$display($time, "=> fpga_delay_valid after  : valid_delay=%x", valid_delay); 
            fpga_axi_awvalid <= 1;
            fpga_axi_wvalid <= 1;
            @ (posedge fpga_coreclk);
            while (fpga_axi_awready == 0) begin        //assume both fpga_axi_awready and fpga_axi_wready assert as the same time.
                    @ (posedge fpga_coreclk);
            end
            $display($time, "=> fpga_cfg_write : fpga_axi_awaddr=%x, fpga_axi_awvalid=%b, fpga_axi_awready=%b, fpga_axi_wdata=%x, axi_wstrb=%x, fpga_axi_wvalid=%b, fpga_axi_wready=%b", fpga_axi_awaddr, fpga_axi_awvalid, fpga_axi_awready, fpga_axi_wdata, axi_wstrb, fpga_axi_wvalid, fpga_axi_wready); 
            fpga_axi_awvalid <= 0;
            fpga_axi_wvalid <= 0;
        end
        
    endtask

  task wait_and_check_soc_to_fpga_mailbox_write_event;
    begin
      //tony_debug wait(soc_to_fpga_mailbox_write_event.triggered);
      @(soc_to_fpga_mailbox_write_event);
            $display($time, "=> wait_and_check_soc_to_fpga_mailbox_write_event : got soc_to_fpga_mailbox_write_event");
            //Address part
      check_cnt = check_cnt + 1;
            if ( soc_to_fpga_mailbox_write_addr_expect_value !== soc_to_fpga_mailbox_write_addr_captured[27:0]) begin
                $display($time, "=> wait_and_check_soc_to_fpga_mailbox_write_event [ERROR] soc_to_fpga_mailbox_write_addr_expect_value=%x, soc_to_fpga_mailbox_write_addr_captured[27:0]=%x", soc_to_fpga_mailbox_write_addr_expect_value, soc_to_fpga_mailbox_write_addr_captured[27:0]);
                error_cnt = error_cnt + 1;
            end    
            else
                $display($time, "=> wait_and_check_soc_to_fpga_mailbox_write_event [PASS] soc_to_fpga_mailbox_write_addr_expect_value=%x, soc_to_fpga_mailbox_write_addr_captured[27:0]=%x", soc_to_fpga_mailbox_write_addr_expect_value, soc_to_fpga_mailbox_write_addr_captured[27:0]);

            //BE part
      check_cnt = check_cnt + 1;
            if ( soc_to_fpga_mailbox_write_addr_BE_expect_value !== soc_to_fpga_mailbox_write_addr_captured[31:28]) begin
                $display($time, "=> wait_and_check_soc_to_fpga_mailbox_write_event [ERROR] soc_to_fpga_mailbox_write_addr_BE_expect_value=%x, soc_to_fpga_mailbox_write_addr_captured[31:28]=%x", soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_addr_captured[31:28]);
                error_cnt = error_cnt + 1;
            end    
            else
                $display($time, "=> wait_and_check_soc_to_fpga_mailbox_write_event [PASS] soc_to_fpga_mailbox_write_addr_BE_expect_value=%x, soc_to_fpga_mailbox_write_addr_captured[31:28]=%x", soc_to_fpga_mailbox_write_addr_BE_expect_value, soc_to_fpga_mailbox_write_addr_captured[31:28]);

            //data part
      check_cnt = check_cnt + 1;
            if (soc_to_fpga_mailbox_write_data_expect_value !== soc_to_fpga_mailbox_write_data_captured) begin
                $display($time, "=> wait_and_check_soc_to_fpga_mailbox_write_event [ERROR] soc_to_fpga_mailbox_write_data_expect_value=%x, soc_to_fpga_mailbox_write_data_captured=%x", soc_to_fpga_mailbox_write_data_expect_value, soc_to_fpga_mailbox_write_data_captured);
                error_cnt = error_cnt + 1;
            end    
            else
                $display($time, "=> wait_and_check_soc_to_fpga_mailbox_write_event [PASS] soc_to_fpga_mailbox_write_data_expect_value=%x, soc_to_fpga_mailbox_write_data_captured=%x", soc_to_fpga_mailbox_write_data_expect_value, soc_to_fpga_mailbox_write_data_captured);
            $display("-----------------");
      @(posedge fpga_coreclk);
        
    end
  endtask

    initial begin        //get upstream soc_to_fpga_axilite_read_completion
        while (1) begin
            @(posedge fpga_coreclk);
            if (fpga_is_as_tvalid == 1 && fpga_is_as_tid == TID_UP_AA && fpga_is_as_tuser == TUSER_AXILITE_READ_CPL) begin
                $display($time, "=> get soc_to_fpga_axilite_read_cpl_captured be : soc_to_fpga_axilite_read_cpl_captured =%x, fpga_is_as_tdata=%x", soc_to_fpga_axilite_read_cpl_captured, fpga_is_as_tdata);
                soc_to_fpga_axilite_read_cpl_captured = fpga_is_as_tdata ;        //use block assignment
                $display($time, "=> get soc_to_fpga_axilite_read_cpl_captured af : soc_to_fpga_axilite_read_cpl_captured =%x, fpga_is_as_tdata=%x", soc_to_fpga_axilite_read_cpl_captured, fpga_is_as_tdata);
                #0 -> soc_to_fpga_axilite_read_cpl_event;
                $display($time, "=> soc_to_fpga_axilite_read_cpl_captured : send soc_to_fpga_axilite_read_cpl_event");
            end    
        end
    end

  wire   uart_tx;
  assign uart_tx = mprj_io[6];


  tbuart tbuart (.ser_rx(uart_tx));  // I

  // -------------------------------------------------------
  `include "bench_vec.svh"

  // -------------------------------------------------------
  `ifdef    CPU_TRACE
  `include "cpu_trace.v"
  `include "dasm.v"
  `endif // CPU_TRACE

endmodule // top_bench

  `include "fpga.v"
//  `include "fsic_clock.v"
//  `include "fsic_coreclk_phase_cnt.v.v"
//  `include "fsic_io_serdes_rx.v"
  `include "io_serdes.v"
  




////`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////////////////////
//// Author: TonyHo
////
//// Create Date: 07/17/2023 04:35:34 PM
//// Design Name:
//// Module Name: fpga
//// Project Name:
//// Target Devices:
//// Tool Versions:
//// Description:
////
//// Dependencies:
////
//// Revision:
//// Revision 0.01 - File Created
//// Additional Comments:
////
////////////////////////////////////////////////////////////////////////////////////
//
//
//module fpga #(
//		parameter pSERIALIO_WIDTH   = 12,
//		parameter pADDR_WIDTH   = 15,
//		parameter pDATA_WIDTH   = 32,
//		parameter pRxFIFO_DEPTH = 5,
//		parameter pCLK_RATIO =4
//	) (
//		input wire 	ioclk,
//
//		input wire 	axi_reset_n,
//		input wire 	axi_clk,
//
//		input wire 	axis_rst_n,
//		input wire 	axis_clk,
//
//		//write addr channel
//		input wire 	axi_awvalid_s_awvalid,
//		input wire 	[pADDR_WIDTH-1:0] axi_awaddr_s_awaddr,		//axi_awaddr is DW address
//		output wire	axi_awready_axi_awready3,
//
//		//write data channel
//		input wire 	axi_wvalid_s_wvalid,
//		input wire 	[pDATA_WIDTH-1:0] axi_wdata_s_wdata,
//		input wire 	[(pDATA_WIDTH/8)-1:0] axi_wstrb_s_wstrb,
//		output wire	axi_wready_axi_wready3,
//
//		//read addr channel
//		input wire 	axi_arvalid_s_arvalid,
//		input wire 	[pADDR_WIDTH-1:0] axi_araddr_s_araddr,
//		output wire 	axi_arready_axi_arready3,
//
//		//read data channel
//		output wire 	axi_rvalid_axi_rvalid3,
//		output wire 	[pDATA_WIDTH-1:0] axi_rdata_axi_rdata3,
//		input wire 	axi_rready_s_rready,
//
//		input wire 	cc_is_enable,		//axi_lite enable
//
//
//
//		//TX path
//		input wire 	[pDATA_WIDTH-1:0] as_is_tdata,
//		input wire 	[(pDATA_WIDTH/8)-1:0] as_is_tstrb,
//		input wire 	[(pDATA_WIDTH/8)-1:0] as_is_tkeep,
//		input wire 	as_is_tlast,
//		input wire 	[1:0] as_is_tid,
//		input wire 	as_is_tvalid,
//		input wire 	[1:0] as_is_tuser,
//		input wire 	as_is_tready,		//when local side axis switch Rxfifo size <= threshold then as_is_tready=0, this flow control mechanism is for notify remote side do not provide data with is_as_tvalid=1
//
//		output wire		  serial_tclk,
//		output wire  [pSERIALIO_WIDTH-1: 0] serial_txd,
//
//		//Rx path
//		input  wire		  serial_rclk,
//		input  wire  [pSERIALIO_WIDTH-1: 0] serial_rxd,
//
//		output wire 	[pDATA_WIDTH-1:0] is_as_tdata,
//		output wire 	[(pDATA_WIDTH/8)-1:0] is_as_tstrb,
//		output wire 	[(pDATA_WIDTH/8)-1:0] is_as_tkeep,
//		output wire 	is_as_tlast,
//		output wire 	[1:0] is_as_tid,
//		output wire 	is_as_tvalid,
//		output wire 	[1:0] is_as_tuser,
//		output wire 	is_as_tready		//when remote side axis switch Rxfifo size <= threshold then is_as_tready=0, this flow control mechanism is for notify local side do not provide data with as_is_tvalid=1
//
//    );
//
//	
//// This code snippet was auto generated by xls2vlog.py from source file: /home/patrick/Downloads/Interface-Definition.xlsx
//// User: patrick
//// Date: Jul-14-23
//
//
//
//IO_SERDES #(.pSERIALIO_WIDTH( 12 ),
//            .pADDR_WIDTH( pADDR_WIDTH ),
//            .pDATA_WIDTH( 32 ),
//            .pRxFIFO_DEPTH( 5 ),
//            .pCLK_RATIO      ( 4 )) U_IO_SERDES0 (
//                                                  .axi_awready  (axi_awready_axi_awready3),// O  
//                                                  .axi_wready   (axi_wready_axi_wready3),  // O  
//                                                  .axi_arready  (axi_arready_axi_arready3),// O  
//                                                  .axi_rdata    (axi_rdata_axi_rdata3),    // O  32
//                                                  .axi_rvalid   (axi_rvalid_axi_rvalid3),  // O  
//                                                  .is_as_tdata  (is_as_tdata),             // O  32
//                                                  .is_as_tstrb  (is_as_tstrb),             // O  4
//                                                  .is_as_tkeep  (is_as_tkeep),             // O  4
//                                                  .is_as_tlast  (is_as_tlast),             // O  
//                                                  .is_as_tid    (is_as_tid),               // O  2
//                                                  .is_as_tvalid (is_as_tvalid),            // O  
//                                                  .is_as_tuser  (is_as_tuser),             // O  2
//                                                  .is_as_tready (is_as_tready),            // O  
//                                                  .axi_awvalid  (axi_awvalid_s_awvalid),   // I  
//                                                  .axi_awaddr   (axi_awaddr_s_awaddr),     // I  12
//                                                  .axi_wvalid   (axi_wvalid_s_wvalid),     // I  
//                                                  .axi_wdata    (axi_wdata_s_wdata),       // I  32
//                                                  .axi_wstrb    (axi_wstrb_s_wstrb),       // I  4
//                                                  .axi_arvalid  (axi_arvalid_s_arvalid),   // I  
//                                                  .axi_araddr   (axi_araddr_s_araddr),     // I  12
//                                                  .axi_rready   (axi_rready_s_rready),     // I  
//                                                  .cc_is_enable (cc_is_enable),            // I  
//                                                  .as_is_tdata  (as_is_tdata),             // I  32
//                                                  .as_is_tstrb  (as_is_tstrb),             // I  4
//                                                  .as_is_tkeep  (as_is_tkeep),             // I  4
//                                                  .as_is_tlast  (as_is_tlast),             // I  
//                                                  .as_is_tid    (as_is_tid),               // I  2
//                                                  .as_is_tvalid (as_is_tvalid),            // I  
//                                                  .as_is_tuser  (as_is_tuser),             // I  2
//                                                  .as_is_tready (as_is_tready),            // I  
//                                                  .ioclk        (ioclk),                   // I  
//                                                  .serial_rxd   (serial_rxd),              // I  12
//                                                  .serial_rclk  (serial_rclk),             // I  
//                                                  .serial_txd   (serial_txd),              // O  12
//                                                  .serial_tclk  (serial_tclk),             // O  
//                                                  .axi_clk      (axi_clk),                 // I  
//                                                  .axi_reset_n  (axi_reset_n),             // I  
//                                                  .axis_clk     (axis_clk),                // I  
//                                                  .axis_rst_n   (axis_rst_n)               // I  
//                                                 );
//
//	
//endmodule


////`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////////////////////
//// Author : Tony Ho
////
//// Create Date: 06/18/2023 10:44:18 PM
//// Design Name:
//// Module Name: IO_SERDES
//// Project Name:
//// Target Devices:
//// Tool Versions:
//// Description:
////
//// Dependencies:
////
//// Revision:
//// Revision 0.01 - File Created
//// Additional Comments:
////
////////////////////////////////////////////////////////////////////////////////////
//// 20230720
//// 1. change pADDR_WIDTH=15 and use [pADDR_WIDTH-1:0] for *_axi_awaddr and *_axi_araddr
//// 20230714
//// 1. change [pADDR_WIDTH-1:0] axi_awaddr to [pADDR_WIDTH+1:2] axi_awaddr for DW base address
//// 2. add pSERIALIO_WIDTH and pSERIALIO_TDATA_WIDTH
//// 3. add is_as_dummy for remove WARNING message
//// 4. update typo in pSERIALIO_TDATA_WIDTH
//// 5. update tpyo, change cc_ls_enable to cc_is_enable
//// 20230712
//// 1. axi_awaddr is DW address, pADDR_WIDTH change from 12 to 10
//// 2. define USE_FOR_LOOP_Serial_Data_Out_tdata and update coding error in for loop
//
//`define USE_FOR_LOOP_Serial_Data_Out_tdata 1
//
//module IO_SERDES #(
//		parameter pSERIALIO_WIDTH   = 12,
//		parameter pADDR_WIDTH   = 15,
//		parameter pDATA_WIDTH   = 32,
//		parameter pRxFIFO_DEPTH = 5,
//		parameter pCLK_RATIO =4
//	) (
//
//
//		input wire 	ioclk,
//
//		input wire 	axi_reset_n,
//		input wire 	axi_clk,
//
//		input wire 	axis_rst_n,
//		input wire 	axis_clk,
//
//		//write addr channel
//		input wire 	axi_awvalid,
//		input wire 	[pADDR_WIDTH-1:0] axi_awaddr,		//axi_awaddr is DW address
//		output wire	axi_awready,
//
//		//write data channel
//		input wire 	axi_wvalid,
//		input wire 	[pDATA_WIDTH-1:0] axi_wdata,
//		input wire 	[(pDATA_WIDTH/8)-1:0] axi_wstrb,
//		output wire	axi_wready,
//
//		//read addr channel
//		input wire 	axi_arvalid,
//		input wire 	[pADDR_WIDTH-1:0] axi_araddr,
//		output wire 	axi_arready,
//
//		//read data channel
//		output wire 	axi_rvalid,
//		output wire 	[pDATA_WIDTH-1:0] axi_rdata,
//		input wire 	axi_rready,
//
//		input wire 	cc_is_enable,		//axi_lite enable
//
//
//
//		//TX path
//		input wire 	[pDATA_WIDTH-1:0] as_is_tdata,
//		input wire 	[(pDATA_WIDTH/8)-1:0] as_is_tstrb,
//		input wire 	[(pDATA_WIDTH/8)-1:0] as_is_tkeep,
//		input wire 	as_is_tlast,
//		input wire 	[1:0] as_is_tid,
//		input wire 	as_is_tvalid,
//		input wire 	[1:0] as_is_tuser,
//		input wire 	as_is_tready,		//when local side axis switch Rxfifo size <= threshold then as_is_tready=0, this flow control mechanism is for notify remote side do not provide data with is_as_tvalid=1
//
//		output wire		  serial_tclk,
//		output wire  [pSERIALIO_WIDTH-1: 0] serial_txd,
//
//		//Rx path
//		input  wire		  serial_rclk,
//		input  wire  [pSERIALIO_WIDTH-1: 0] serial_rxd,
//
//		output wire 	[pDATA_WIDTH-1:0] is_as_tdata,
//		output wire 	[(pDATA_WIDTH/8)-1:0] is_as_tstrb,
//		output wire 	[(pDATA_WIDTH/8)-1:0] is_as_tkeep,
//		output wire 	is_as_tlast,
//		output wire 	[1:0] is_as_tid,
//		output wire 	is_as_tvalid,
//		output wire 	[1:0] is_as_tuser,
//		output wire 	is_as_tready		//when remote side axis switch Rxfifo size <= threshold then is_as_tready=0, this flow control mechanism is for notify local side do not provide data with as_is_tvalid=1
//
//	);
//
//	localparam pSERIALIO_TDATA_WIDTH	= pDATA_WIDTH/pCLK_RATIO;
//	
//	wire coreclk;
//	wire txclk;
//	wire rxclk;
//	wire axi_awvalid_in;
//	wire axi_wvalid_in;
//	wire txen_out;
//	wire is_as_tready_remote;
//	
//	assign coreclk = axis_clk;
//	assign serial_tclk = txclk;
//	assign rxclk = serial_rclk;
//
//	wire Serial_Data_Out_tlast_tvalid_tready;
//	wire Serial_Data_Out_tid_tuser;
//	wire Serial_Data_Out_tkeep;
//	wire Serial_Data_Out_tstrb;
//	wire [pSERIALIO_TDATA_WIDTH-1:0] Serial_Data_Out_tdata;
//
//	assign 	serial_txd[pSERIALIO_WIDTH-1:0] = {Serial_Data_Out_tlast_tvalid_tready, Serial_Data_Out_tid_tuser, Serial_Data_Out_tkeep, Serial_Data_Out_tstrb, Serial_Data_Out_tdata[pSERIALIO_TDATA_WIDTH-1:0]};
//
//	wire Serial_Data_In_tlast_tvalid_tready;
//	wire Serial_Data_In_tid_tuser;
//	wire Serial_Data_In_tkeep;
//	wire Serial_Data_In_tstrb;
//	wire [pSERIALIO_TDATA_WIDTH-1:0] Serial_Data_In_tdata;
//
//	assign {Serial_Data_In_tlast_tvalid_tready, Serial_Data_In_tid_tuser, Serial_Data_In_tkeep, Serial_Data_In_tstrb, Serial_Data_In_tdata[pSERIALIO_TDATA_WIDTH-1:0] } = serial_rxd[pSERIALIO_WIDTH-1:0];
//
//	reg	txen;
//
//	//register offset 0
//	reg rxen_ctl;	//bit 0
//	reg txen_ctl;	//bit 1
//
//	//write addr channel
//	assign 	axi_awvalid_in	= axi_awvalid && cc_is_enable;
//	wire axi_awready_out;
//	assign axi_awready = axi_awready_out;
//
//	//write data channel
//	assign 	axi_wvalid_in	= axi_wvalid && cc_is_enable;
//	wire axi_wready_out;
//	assign axi_wready = axi_wready_out;
//
//	// if both axi_awvalid_in=1 and axi_wvalid_in=1 then output axi_awready_out = 1 and axi_wready_out = 1
//	assign axi_awready_out = (axi_awvalid_in && axi_wvalid_in) ? 1 : 0;
//	assign axi_wready_out = (axi_awvalid_in && axi_wvalid_in) ? 1 : 0;
//
//
//	//write register
//	always @(posedge axi_clk or negedge axi_reset_n)  begin
//		if ( !axi_reset_n ) begin
//			rxen_ctl <= 0;
//			txen_ctl <= 0;
//		end
//		else begin
//			if ( axi_awvalid_in && axi_wvalid_in ) begin		//when axi_awvalid_in=1 and axi_wvalid_in=1 means axi_awready_out=1 and axi_wready_out=1
//				if (axi_awaddr[11:2] == 10'h000 && (axi_wstrb[0] == 1) ) begin //offset 0
//					rxen_ctl <= axi_wdata[0];
//					txen_ctl <= axi_wdata[1];
//				end
//				else begin
//					rxen_ctl <= rxen_ctl;
//					txen_ctl <= txen_ctl;
//				end
//			end
//		end
//	end
//
//
//	// io serdes always output axi_arready = 1 and don't care the axi_arvalid & axi_araddr
//	// io serdes only support 2 register bits in offset 0. config read other address offset is reserved.
//	assign axi_arready = 1;
//	// io serdes always output axi_rvalid = 1 and axi_rdata =  { 30'b0, txen_ctl, rxen_ctl }
//	assign axi_rvalid = 1;
//	assign axi_rdata =  { 30'b0, txen_ctl, rxen_ctl };
//
//
//
//	assign txen_out = txen;
//
//	wire [$clog2(pCLK_RATIO)-1:0] phase_cnt;
//
//	fsic_coreclk_phase_cnt  #(
//		.pCLK_RATIO(pCLK_RATIO)
//	)
//	fsic_coreclk_phase_cnt_0(
//		.axis_rst_n(axis_rst_n),
//		.ioclk(ioclk),
//		.coreclk(coreclk),
//		.phase_cnt_out(phase_cnt)
//	);
//
//
//// For Tx Path
//
//	wire	rx_received_data;
//
//
//	always @(negedge ioclk or negedge axis_rst_n)  begin
//		if ( !axis_rst_n ) begin
//			txen <= 0;
//		end
//		else begin
//			if ( (txen_ctl || rx_received_data) && phase_cnt == 3   )	// set txen=1 when timeout or rx_received_data==1
//																			// if rx_received_data==1 before timeout, it means remote side txen is ealry then local side.
//																			// then we should set local site txen=1 to allow local site provide ready signal to remote side in tx path.
//																			// It is to avoid local site rx fifo full in axis switch.
//				txen <= 1;
//			else
//				txen <= txen;
//		end
//	end
//
//	reg [$clog2(pCLK_RATIO)-1:0] tx_shift_phase_cnt;
//
//
//	always @(posedge ioclk or negedge axis_rst_n)  begin
//		if ( !axis_rst_n ) begin
//			tx_shift_phase_cnt <= 3;
//		end
//		else begin
//			if (txen)
//				tx_shift_phase_cnt <= tx_shift_phase_cnt + 1;
//			else
//				tx_shift_phase_cnt <= tx_shift_phase_cnt;
//		end
//	end
//
//	reg [pDATA_WIDTH-1:0] pre_as_is_tdata_buf;
//	reg [(pDATA_WIDTH/8)-1:0] pre_as_is_tstrb_buf;
//	reg [(pDATA_WIDTH/8)-1:0] pre_as_is_tkeep_buf;
//	reg [(pDATA_WIDTH/8)-1:0] pre_as_is_tid_tuser_buf;
//	reg [(pDATA_WIDTH/8)-1:0] pre_as_is_tlast_tvalid_tready_buf;
//
//	always @(negedge coreclk or negedge axis_rst_n)  begin
//		pre_as_is_tdata_buf <= as_is_tdata;
//		pre_as_is_tstrb_buf <= as_is_tstrb;
//		pre_as_is_tkeep_buf <= as_is_tkeep;
//		pre_as_is_tid_tuser_buf[3:2] <= as_is_tid;
//		pre_as_is_tid_tuser_buf[1:0] <= as_is_tuser;
//		pre_as_is_tlast_tvalid_tready_buf[2] <= as_is_tlast;
//		pre_as_is_tlast_tvalid_tready_buf[1] <= as_is_tvalid;
//		pre_as_is_tlast_tvalid_tready_buf[0] <= as_is_tready;
//
//		if ( !axis_rst_n ) begin
//			pre_as_is_tdata_buf <= 0;
//			pre_as_is_tstrb_buf <= 0;
//			pre_as_is_tkeep_buf <= 0;
//			pre_as_is_tid_tuser_buf <= 0;
//			pre_as_is_tlast_tvalid_tready_buf <= 0;
//		end 
//        else if ( ~txen) begin
//			pre_as_is_tdata_buf <= 0;
//			pre_as_is_tstrb_buf <= 0;
//			pre_as_is_tkeep_buf <= 0;
//			pre_as_is_tid_tuser_buf <= 0;
//			pre_as_is_tlast_tvalid_tready_buf <= 0;
//		end
//		else begin
//			if (is_as_tready && as_is_tvalid) begin			//data transfer from Axis siwtch to io serdes when is_as_tready=1 and as_is_tvalid=1
//				pre_as_is_tlast_tvalid_tready_buf[1] <= as_is_tvalid;
//			end
//			else begin
//				pre_as_is_tlast_tvalid_tready_buf[1] <= 0;			// set as_is_tvalid =0 to remote side
//			end
//		end
//	end
//
//	reg [pDATA_WIDTH-1:0] as_is_tdata_buf;
//	reg [(pDATA_WIDTH/8)-1:0] as_is_tstrb_buf;
//	reg [(pDATA_WIDTH/8)-1:0] as_is_tkeep_buf;
//	reg [(pDATA_WIDTH/8)-1:0] as_is_tid_tuser_buf;
//	reg [(pDATA_WIDTH/8)-1:0] as_is_tlast_tvalid_tready_buf;
//
//	always @(posedge ioclk or negedge axis_rst_n)  begin
//		if ( !axis_rst_n ) begin
//			as_is_tdata_buf <= 0;
//			as_is_tstrb_buf <= 0;
//			as_is_tkeep_buf <= 0;
//			as_is_tid_tuser_buf <= 0;
//			as_is_tlast_tvalid_tready_buf <= 0;
//		end
//		else begin
//			if (phase_cnt == 3) begin			//update as_is_*_buf when phase_cnt == 3
//				as_is_tdata_buf <= pre_as_is_tdata_buf;
//				as_is_tstrb_buf <= pre_as_is_tstrb_buf;
//				as_is_tkeep_buf <= pre_as_is_tkeep_buf;
//				as_is_tid_tuser_buf <= pre_as_is_tid_tuser_buf;
//				as_is_tlast_tvalid_tready_buf <= pre_as_is_tlast_tvalid_tready_buf;
//			end
//		end
//	end
//
//	assign txclk = ioclk&txen;		//use negedge to avoid glitch in txclk.
//
//
//`ifdef USE_FOR_LOOP_Serial_Data_Out_tdata
//	genvar j;
//	generate
//		for (j=0; j<pSERIALIO_TDATA_WIDTH; j=j+1 ) begin
//			assign Serial_Data_Out_tdata[j] = as_is_tdata_buf[j*4+tx_shift_phase_cnt] & txen ;
//		end
//	endgenerate
//`else	//USE_FOR_LOOP_Serial_Data_Out_tdata
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_0;
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_1;
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_2;
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_3;
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_4;
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_5;
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_6;
//	wire [(pDATA_WIDTH/8)-1:0] as_is_tdata_7;
//
//	assign as_is_tdata_0 = as_is_tdata_buf[3:0];
//	assign as_is_tdata_1 = as_is_tdata_buf[7:4];
//	assign as_is_tdata_2 = as_is_tdata_buf[11:8];
//	assign as_is_tdata_3 = as_is_tdata_buf[15:12];
//	assign as_is_tdata_4 = as_is_tdata_buf[19:16];
//	assign as_is_tdata_5 = as_is_tdata_buf[23:20];
//	assign as_is_tdata_6 = as_is_tdata_buf[27:24];
//	assign as_is_tdata_7 = as_is_tdata_buf[31:28];
//
//	assign Serial_Data_Out_tdata[0] = as_is_tdata_0[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tdata[1] = as_is_tdata_1[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tdata[2] = as_is_tdata_2[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tdata[3] = as_is_tdata_3[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tdata[4] = as_is_tdata_4[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tdata[5] = as_is_tdata_5[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tdata[6] = as_is_tdata_6[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tdata[7] = as_is_tdata_7[tx_shift_phase_cnt] & txen ;
//`endif	//USE_FOR_LOOP_Serial_Data_Out_tdata
//
//
//	assign Serial_Data_Out_tstrb = as_is_tstrb_buf[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tkeep = as_is_tkeep_buf[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tid_tuser = as_is_tid_tuser_buf[tx_shift_phase_cnt] & txen ;
//	assign Serial_Data_Out_tlast_tvalid_tready = as_is_tlast_tvalid_tready_buf[tx_shift_phase_cnt] & txen ;
//
//
//
//// For Rx Path
//	wire rxdata_out_valid[pSERIALIO_TDATA_WIDTH+2:0];		//add dummy connection to avoid WARNING message by xelab
//
//	reg	rxen;
//
//	always @(negedge ioclk or negedge axis_rst_n)  begin
//		if ( !axis_rst_n ) begin
//			rxen <= 0;
//		end
//		else begin
//			if (rxen_ctl)
//				rxen <= 1;
//			else
//				rxen <= rxen;
//		end
//	end
//
//
//	genvar i;
//	generate
//		for (i=0; i<pSERIALIO_TDATA_WIDTH; i=i+1 ) begin
//
//			fsic_io_serdes_rx  #(
//				.pRxFIFO_DEPTH(pRxFIFO_DEPTH),
//				.pCLK_RATIO(pCLK_RATIO)
//			)
//			fsic_io_serdes_rx_tdata(
//				.axis_rst_n(axis_rst_n),
//				.rxclk(rxclk),
//				.rxen(rxen),
//				.ioclk(ioclk),
//				.coreclk(coreclk),
//				.Serial_Data_in(Serial_Data_In_tdata[i]),
//				.rxdata_out(is_as_tdata[i*4+3:i*4]),
//				.rxdata_out_valid(rxdata_out_valid[i])
//			);
//
//		end
//	endgenerate
//
//
//	fsic_io_serdes_rx  #(
//		.pRxFIFO_DEPTH(pRxFIFO_DEPTH),
//		.pCLK_RATIO(pCLK_RATIO)
//	)
//	fsic_io_serdes_rx_tstrb(
//		.axis_rst_n(axis_rst_n),
//		.rxclk(rxclk),
//		.rxen(rxen),
//		.ioclk(ioclk),
//		.coreclk(coreclk),
//		.Serial_Data_in(Serial_Data_In_tstrb),
//		.rxdata_out(is_as_tstrb),
//		.rxdata_out_valid(rxdata_out_valid[pSERIALIO_TDATA_WIDTH])
//	);
//
//
//	fsic_io_serdes_rx  #(
//		.pRxFIFO_DEPTH(pRxFIFO_DEPTH),
//		.pCLK_RATIO(pCLK_RATIO)
//	)
//	fsic_io_serdes_rx_tkeep(
//		.axis_rst_n(axis_rst_n),
//		.rxclk(rxclk),
//		.rxen(rxen),
//		.ioclk(ioclk),
//		.coreclk(coreclk),
//		.Serial_Data_in(Serial_Data_In_tkeep),
//		.rxdata_out(is_as_tkeep),
//		.rxdata_out_valid(rxdata_out_valid[pSERIALIO_TDATA_WIDTH+1])
//	);
//
//	fsic_io_serdes_rx  #(
//		.pRxFIFO_DEPTH(pRxFIFO_DEPTH),
//		.pCLK_RATIO(pCLK_RATIO)
//	)
//	fsic_io_serdes_rx_tid_tuser(
//		.axis_rst_n(axis_rst_n),
//		.rxclk(rxclk),
//		.rxen(rxen),
//		.ioclk(ioclk),
//		.coreclk(coreclk),
//		.Serial_Data_in(Serial_Data_In_tid_tuser),
//		.rxdata_out( {is_as_tid[1:0], is_as_tuser[1:0]}),
//		.rxdata_out_valid(rxdata_out_valid[pSERIALIO_TDATA_WIDTH+2])
//	);
//
//    wire is_as_dummy;
//
//	fsic_io_serdes_rx  #(
//		.pRxFIFO_DEPTH(pRxFIFO_DEPTH),
//		.pCLK_RATIO(pCLK_RATIO)
//	)
//	fsic_io_serdes_rx_fc(
//		.axis_rst_n(axis_rst_n),
//		.rxclk(rxclk),
//		.rxen(rxen),
//		.ioclk(ioclk),
//		.coreclk(coreclk),
//		.Serial_Data_in(Serial_Data_In_tlast_tvalid_tready),
//		.rxdata_out( {is_as_dummy, is_as_tlast, is_as_tvalid, is_as_tready_remote}),	  // only connect [2:0]
//		.rxdata_out_valid(rx_received_data)
//	);
//
//	reg is_as_tready_out;
//	assign is_as_tready = is_as_tready_out;
//
//	always @(posedge coreclk or negedge axis_rst_n)  begin
//		if ( !axis_rst_n ) begin
//			is_as_tready_out <= 0;				//set is_as_tready_out=0
//		end
//		else if ( !txen ) begin
//			is_as_tready_out <= 0;				//set is_as_tready_out=0
//		end
//		else begin
//			if (rx_received_data == 0) is_as_tready_out <= 1;		// when txen==1 and still not recevies data from remote side then set is_as_tready_out=1 to avoid dead lock issue.
//			else	is_as_tready_out <= is_as_tready_remote;				// when txen == 1 and rx_received_data==1 (received data from remote side) then is_as_tready_out come from is_as_tready_remote (remote side)
//		end
//	end
//
//
//endmodule


//////////////////////////////////////////////////////////////////////////////////
// Author : Tony Ho
//
//
// Create Date: 07/10/2023 11:39:49 AM
// Design Name:
// Module Name: fsic_coreclk_phase_cnt
// Project Name:
// Target Devices:
// Tool Versions:
// Description:
//
// Dependencies:
//
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
//
//////////////////////////////////////////////////////////////////////////////////


module fsic_coreclk_phase_cnt#(
		parameter pCLK_RATIO =4
	) (
		input wire 	axis_rst_n,
		input wire 	ioclk,
		input wire 	coreclk,
		output wire	[$clog2(pCLK_RATIO)-1:0] phase_cnt_out
	);

    reg [pCLK_RATIO-1:0] clk_seq;
    reg [$clog2(pCLK_RATIO)-1:0] phase_cnt;
    assign phase_cnt_out = phase_cnt;

	reg core_clk_toggle;
    always @(posedge coreclk or negedge axis_rst_n) begin
        if ( !axis_rst_n ) begin
            core_clk_toggle <= 0;
        end
        else begin
            core_clk_toggle <= ~core_clk_toggle;
        end
    end

	reg pre_core_clk_toggle;
	reg sync_core_clk_toggle;
	
    always @(posedge ioclk or negedge axis_rst_n) begin
        if ( !axis_rst_n ) begin
            pre_core_clk_toggle <= 0;
            sync_core_clk_toggle <= 0;
        end
        else begin
			pre_core_clk_toggle <= core_clk_toggle;
			sync_core_clk_toggle <= pre_core_clk_toggle;		//avoid metastable issue.
        end
    end


    always @(posedge ioclk or negedge axis_rst_n) begin
        if ( !axis_rst_n ) begin
            clk_seq <= 0;
        end
        else begin
            clk_seq[pCLK_RATIO-1:1] <=  clk_seq[pCLK_RATIO-2:0];
            clk_seq[0] <=  sync_core_clk_toggle;
        end
    end


    always @(posedge ioclk or negedge axis_rst_n) begin
        if ( !axis_rst_n) begin
            phase_cnt <= 0;
        end
        else begin
            if ( (clk_seq == 4'h3) || (clk_seq == 4'hc) )
                phase_cnt <= 0;
            else
                phase_cnt <= phase_cnt + 1;
        end
    end

endmodule
//`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Author : Tony Ho
//
//
// Create Date: 07/10/2023 11:45:06 AM
// Design Name:
// Module Name: fsic_io_serdes_rx
// Project Name:
// Target Devices:
// Tool Versions:
// Description:
//
// Dependencies:
//
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
//
//////////////////////////////////////////////////////////////////////////////////
//20230724
//1. rx_sync_fifo output to rxdata_out for reduce 1T.

module fsic_io_serdes_rx#(
		parameter pRxFIFO_DEPTH = 5,
		parameter pCLK_RATIO =4
	) (
		input wire 	axis_rst_n,
		input wire 	rxclk,
		input wire   rxen,
		input wire 	ioclk,
		input wire 	coreclk,
		input wire 	Serial_Data_in,
		output wire 	[pCLK_RATIO-1:0] rxdata_out,
		output wire 	rxdata_out_valid
	);


	reg [$clog2(pRxFIFO_DEPTH)-1:0] w_ptr;
	reg w_ptr_pre;
	reg w_ptr_sync;
	wire rx_shift_reg_valid;

	wire w_ptr_graycode_bit0;

	assign w_ptr_graycode_bit0 = w_ptr[1] ^  w_ptr[0];

	always @(negedge rxclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			w_ptr <= 0;
		end
		else if ( !rxen ) begin
			w_ptr <= 0;
		end
		else begin
			if (w_ptr == 4)
				w_ptr <= 0;
			else
				w_ptr <= w_ptr+1;
		end
	end


	reg [pRxFIFO_DEPTH-1:0] RxFifo;


	always @(negedge rxclk or negedge axis_rst_n) begin
		if ( !axis_rst_n ) begin
			RxFifo <= 0;
		end
		else if ( !rxen ) begin
			RxFifo <= 0;
		end
		else begin
			RxFifo[w_ptr] <= Serial_Data_in;
		end
	end



	always @(posedge ioclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			w_ptr_pre <= 0;
			w_ptr_sync <= 0;
		end
		else begin
			w_ptr_pre <= w_ptr_graycode_bit0;		//use gray code
			w_ptr_sync <= w_ptr_pre;				//avoid metastable issue
		end
	end

	reg rx_start;
	always @(posedge ioclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			rx_start <= 0;
		end
		else begin
			if (w_ptr_sync != 0 )
				rx_start <= 1;
			else
				rx_start <= rx_start;
		end
	end


	reg [$clog2(pRxFIFO_DEPTH)-1:0] r_ptr;

	always @(posedge ioclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			r_ptr <= 0;
		end
		else begin
			if (rx_start) begin
				if ( r_ptr == 4 )
					r_ptr <= 0;
				else
					r_ptr <= r_ptr + 1;
			end
			else
				r_ptr <= r_ptr;
		end
	end

	reg [pCLK_RATIO-1:0] rx_shift_reg;

	always @(posedge ioclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			rx_shift_reg <= 0;
		end
		else begin
			if (rx_start) begin
				rx_shift_reg[3] <= RxFifo[r_ptr];		//r_ptr get from LSB to MSB
				rx_shift_reg[2:0] <= rx_shift_reg[3:1];
			end
		end
	end

	reg [$clog2(pCLK_RATIO)-1:0] rx_shift_phase_cnt;

	always @(posedge ioclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			rx_shift_phase_cnt <= pCLK_RATIO-1;
		end
		else begin
			if (rx_start)
				rx_shift_phase_cnt <= rx_shift_phase_cnt+1;
			else
				rx_shift_phase_cnt <= rx_shift_phase_cnt;
		end
	end

	reg [2:0] rx_start_delay;

	always @(posedge ioclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			rx_start_delay <= 0;
		end
		else begin
			rx_start_delay[0] <= rx_start;
			rx_start_delay[2:1] <= rx_start_delay[1:0];
		end
	end

	assign rx_shift_reg_valid = (rx_shift_phase_cnt == pCLK_RATIO-1) && rx_start_delay[2] ; //rx_shift_reg is ready to move.

	//write by ioclk in negedge and read by coreclk in posedge then simulation result is ok.

	reg [pCLK_RATIO-1:0] rx_sync_fifo;
	reg rx_sync_fifo_valid;

	always @(negedge ioclk or negedge axis_rst_n)  begin		// Note : the FPGA provide both coreclk and ioclk to FSIC_SOC, the skew of coreclk and ioclk maybe impact by FPGA output timining -> PCB -> FSIC_SOC input timing.
																// when ioclok early then coreclk in fsic_io_serdes_rx, it may cause hold time issue in rx_shift_reg to rx_sync_fifo.
																// use negdege ioclk to improve the hold time, but it sacrifice the setup time. 
		if ( !axis_rst_n ) begin
			rx_sync_fifo <= 0;
			rx_sync_fifo_valid <= 0;
		end
		else begin
			if (rx_start && rx_shift_reg_valid)  begin
				rx_sync_fifo <= rx_shift_reg;
				rx_sync_fifo_valid <= 1;
			end
			else begin
				rx_sync_fifo <= rx_sync_fifo;
				rx_sync_fifo_valid <= rx_sync_fifo_valid;
			end
		end
	end

	assign rxdata_out = rx_sync_fifo;
	assign rxdata_out_valid = rx_sync_fifo_valid;

/*
	reg [pCLK_RATIO-1:0] rxdata;
	reg rxdata_valid;

	assign rxdata_out = rxdata;
	assign rxdata_out_valid = rxdata_valid;

	always @(posedge coreclk or negedge axis_rst_n)  begin
		if ( !axis_rst_n ) begin
			rxdata <= 0;
			rxdata_valid <= 0;
		end
		else begin
				rxdata <= rx_sync_fifo;
				rxdata_valid <= rx_sync_fifo_valid;
		end
	end
*/


endmodule

//`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Author : Tony Ho
//
// Create Date: 06/23/2023 09:18:34 AM
// Design Name:
// Module Name: fsic_clock
// Project Name:
// Target Devices:
// Tool Versions:
// Description:
//
// Dependencies:
//
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
//
//////////////////////////////////////////////////////////////////////////////////
//20230710
// 2. use counter + FF
//20230710
// 1. using counter to avoid hold time issue when using 2 x clk->q delay from the clk.

`define USE_BLOCK_ASSIGNMENT 1




module fsic_clock_div (
	in, out, resetb
);
	input in;			// input clock
	input resetb;		// asynchronous reset (sense negative)
	output out;			// divided output clock

	reg clk_out;
	assign out = clk_out;
	reg cnt;	 // use 1 bit for support div4

	always @(posedge in or negedge resetb) begin
		if ( !resetb ) begin
		  cnt <= 0;
		end		  
		else  begin
			cnt <= cnt + 1;
		end
	end

`ifdef 	USE_BLOCK_ASSIGNMENT

//for use block assigmnet to avoid race condition in simulation

	always @(posedge in or negedge resetb) begin
		if ( !resetb ) begin
		  clk_out = 1;
		end		  
		else  begin
			if ( cnt == 0 ) clk_out = ~clk_out;
			else clk_out = clk_out;
		end
	end

`else	  //USE_BLOCK_ASSIGNMENT

//for use non-block assigmnet

	always @(posedge in or negedge resetb) begin
		if ( !resetb ) begin
		  clk_out <= 1;
		end		  
		else  begin
			if ( cnt == 0 ) clk_out <= ~clk_out;
			else clk_out <= clk_out;
		end
	end

`endif 		//USE_BLOCK_ASSIGNMENT

endmodule


`default_nettype wire
